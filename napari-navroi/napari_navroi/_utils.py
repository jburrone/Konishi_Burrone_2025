import os
from dask import array as da
import math
import numpy as np
import pandas as pd
from skimage import transform


def affinder_matrix(txtfilename):
  """
  Reads an affine transformation matrix from a text file generated by the napari-affinder app.

  Args:
      txtfilename (str): The path to the text file containing the transformation matrix.

  Returns:
      matrix (np.array): 3x3 affine transformation matrix

  Raises:
      IOError: If the file cannot be opened or read.
      ValueError: If the file format is invalid (expected three comma-separated floats per line).
  """

  try:
    with open(txtfilename, 'r') as file:
      matrix = []
      for line in file:
        line = line.rstrip()
        try:
          m1, m2, m3 = map(np.float32, line.split(','))
          matrix.append((m1, m2, m3))
        except ValueError:
          raise ValueError(f"Invalid line format in file: {txtfilename}")

      return np.array(matrix)

  except IOError as e:
    raise IOError(f"Error opening file: {txtfilename}") from e


def apply_affine_image(image, affine, order, reference_shape):
    """
    Applies affine transformation to image.

    Args:
        image (np.array): Image to be transformed.
        affine (np.array): Affine transformation matrix.
        order (int): The order of the interpolation.
        reference_shape (tuple): Shape of the output image.

    Returns:
        Transformed image (np.array)
    """

    if image.ndim == 2:
        affine = tform_matrix_rc2xy(affine)
    return transform.warp(
            image,
            np.linalg.inv(affine),
            order = order,
            output_shape = reference_shape,
            preserve_range = True
            )


def create_box(img_shape, box_width=3):
    """
    Creates a box around the image.
    
    Args:
        img_shape (list): The image shape to create a box around.
        box_width (int): the thickness of bounding box
    
    Returns:
        np.ndarray: The image with the box drawn around it.
    """

    img_box = np.zeros(img_shape, dtype=np.uint8)

    for iz in range(img_shape[0]):
        img_box[iz, ::1, 0:box_width] = 1
        img_box[iz, ::1, -box_width:-1] = 1
        img_box[iz, 0:box_width, ::1] = 1
        img_box[iz, -box_width:-1, ::1] = 1

    img_box *= 255

    return img_box


def get_affine_params(tform_matrix):
    """
    Extracts affine parameters (scale, shear, rotation, translation)
    from a skimage.transform.AffineTransform object.

    Args:
        tform: The AffineTransform object containing the transformation.

    Returns:
        A dictionary containing the following keys:
            - scale: A list of [scaleX, scaleY].
            - shear: The shear angle in radians.
            - rotation: The rotation angle in radians.
            - translation: A list of [translateX, translateY].

    Example usage (assuming you have a transformation object 'tform')
    params = get_affine_params(tform)

    print("Scale:", params["scale"])
    print("Shear:", params["shear"])
    print("Rotation in deg:", params["rotation"])
    print("Translation:", params["translation"])
    """

    # Get the transformation matrix
    matrix = tform_matrix

    # Extract scale
    scaleX = matrix[0, 0]
    scaleY = matrix[1, 1]
    scale = [scaleX, scaleY]

    # Extract shear (assuming xy shear, adjust for other types if needed)
    shear = matrix[0, 1]

    # Extract rotation (using arctangent on the off-diagonal terms)
    rotation = np.arctan2(matrix[1, 0], matrix[0, 0])

    # Extract translation
    translation = [matrix[0, 2], matrix[1, 2]]

    # Return the parameters as a dictionary
    return {
        "scale": scale,
        "shear": shear,
        "rotation": rotation / math.pi * 180,
        "translation": translation
    }

def is_3ch_image(img):
    """
    Checks if an image is a 3-channel image with height greater than width.

    Args:
        img (array): The image to check.

    Returns:
        True if the image is a 3-channel image with height greater than width, False otherwise.
    """
    
    return len(img.shape) == 3 and img.shape[0] > img.shape[-1]


def is_gray_image(img):
    """Checks if an image is grayscale.

    A grayscale image typically has a 2D shape.

    Args:
        img (array): The image to check.

    Returns:
        True if the image is grayscale, False otherwise.
    """
    return len(img.shape) == 2


def is_zstack_image(img):
    """
    Checks if the given image is a Z-stack image.

    A Z-stack image is a 3D image where the Z-dimension (depth) is smaller
    than the X and Y dimensions (width and height).

    Args:
        img (array): The image to check.

    Returns:
        True if the image is a Z-stack image, False otherwise.
    """
    return len(img.shape) == 3 and img.shape[0] < img.shape[-1]


def make_napari_polygons(rois_csvfile, xres, yres):
    """
    Reads a CSV file containing ROI data and converts it to napari polygons.

    Args:
        rois_csvfile (str): Path to the CSV file containing ROI data.
        xres (float): x pixel resolution
        yres (float): y pixel resolution

    Returns:
        list: A list of napari polygons, where each polygon is a numpy array
            with shape (n, 3) representing the n vertics of the polygon
            in (z, y, x) order.
    """

    rois = pd.read_csv(rois_csvfile)

    # Group rows by index and efficiently extract coordinates
    grouped_rois = rois.groupby('index')

    polygons = []
    for _, group_df in grouped_rois:
        z = group_df.loc[group_df['vertex-index'] == 0, 'axis-0'].iloc[0]
        polygon = []
        for vi in group_df['vertex-index']:
            iy, ix = group_df.loc[group_df['vertex-index'] == vi, ['axis-1', 'axis-2']].iloc[0]
            polygon.append([z, iy*yres, ix*xres])

        polygon = np.array(polygon, dtype=np.float64)
        polygons.append(polygon)

    return polygons


def read_image_pyramid(url, levels=4):
    """
    Reads an image pyramid from a Zarr store.

    Args:
        url (str): The URL of the Zarr store.
        levels (int, optional): The number of levels in the pyramid. Defaults to 4.

    Returns:
        list[dask.array.Array]: A list of Dask arrays representing the image pyramid levels, or -1 if the path is incorrect.
    """

    base_path = f"{url}/data_level_"
    pyramid_levels = [base_path + str(i) for i in range(1, levels + 1)]

    if all(os.path.isdir(level) for level in pyramid_levels):
        pyramid = [da.from_zarr(level) for level in pyramid_levels]
    else:
        print(f"Wrong file path: {base_path}{levels}")
        pyramid = -1

    return pyramid


def Rx(angle):
    """
    Creates a rotation matrix for rotation about the x-axis.
    
    Args:
        angle (float): The rotation angle in degrees.

    Returns:
        np.ndarray: A 3x3 rotation matrix.
    """
    
    # Convert degrees to radians
    rad = np.deg2rad(angle)
    return np.array([[1, 0, 0],
                      [0, math.cos(rad), math.sin(rad)],
                      [0, -math.sin(rad), math.cos(rad)]])


def Ry(angle):
    """
    Creates a rotation matrix for rotation about the y-axis.
    
    Args:
        angle (float): The rotation angle in degrees.

    Returns:
        np.ndarray: A 3x3 rotation matrix.
    """

    # Convert degrees to radians
    rad = np.deg2rad(angle)
    return np.array([[math.cos(rad), 0, -math.sin(rad)],
                      [0, 1, 0],
                      [math.sin(rad), 0, math.cos(rad)]])


def Rz(angle):
    """
    Creates a rotation matrix for rotation about the z-axis.

    Args:
        angle (float): The rotation angle in degrees. 
    
    Returns:
        np.ndarray: A 3x3 rotation matrix.
    """

    # Convert degrees to radians
    rad = np.deg2rad(angle)
    return np.array([[math.cos(rad), math.sin(rad), 0],
                      [-math.sin(rad), math.cos(rad), 0],
                      [0, 0, 1]])


def tform_matrix_rc2xy(affine_matrix):
    """
    Transposes the first and second indices of an affine matrix.

    This makes the matrix match the (soon to be deprecated) skimage convention
    in which the first row matches the second axis of a NumPy array and
    vice-versa.

    Args:
        affine_matrix (np.array): (D+1, D+1) An affine transformation matrix.

    Returns:
        swapped_both (np.array): The 'transposed' affine matrix.
    """

    # swap columns
    swapped_cols = affine_matrix[:, [1, 0, 2]]

    # swap rows
    swapped_both = swapped_cols[[1, 0, 2], :]

    return swapped_both


def transform_point_to_local_frame(S, x_offref, y_offref, z_offref, sx_segreg, sy_segreg):
    """
    Calculates points in the fixed image local frame. The center of the local frame is the same as that of the fixed image.

    Args:
        S (int): The size of the fixed image.
        x_offref (float): The x-offset of the reference image for crop to match the fixed image.
        y_offref (float): The y-offset of the reference image for crop to match the fixed image.
        z_offref (float): The z-offset of the reference image for crop to match the fixed image.
        sx_segreg (float): The x-scaling factor of the moving image returned by image registration tool.
        sy_segreg (float): The y-scaling factor of the moving image returned by image registration tool.

    Returns:
        list[float]: A list of three points representing the x, y, and z coordinates in the fixed image local frame.
    """

    x_local = (x_offref - S / 2) * sx_segreg
    y_local = (y_offref - S / 2) * sy_segreg

    return [x_local, y_local, z_offref]


def transform_point_to_moving_frame(x, y, x_offmov, y_offmov, S, qz_segreg, x_segreg, y_segreg, sx_segreg, sy_segreg):
    """ 
    Transforms a point from the local frame of the fixed image frame to the moving image frame.

    Args:
        x (float): The x-coordinate of the point in the local frame of the fixed image.
        y (float): The y-coordinate of the point in the local frame of the fixed image.
        x_offmov (float): The x-offset of the moving image for crop to match the fixed image.
        y_offmov (float): The y-offset of the moving image for crop to match the fixed image.
        S (int): The size of the fixed image.
        qz_segreg (float): The rotation around the z-axis returned by image registration tool.
        x_segreg (float): The x-offset returned by image registration tool.
        y_segreg (float): The y-offset returned by image registration tool.
        sx_segreg (float): The x-scaling factor of the moving image returned by image registration tool.
        sy_segreg (float): The y-scaling factor of the moving image returned by image registration tool.

    Returns:
        np.ndarray: A 3D array (x, y, _) representing the point in the moving image frame.
    """

    # Create initial points and offsets
    crop_tl_ref  = np.array([x_offmov, y_offmov, 0])
    point = np.array([x, y, 0])
    offset_by_segreg = np.array([x_segreg, y_segreg, 0])

    # Calculate the scaled center offset
    max_scale = max(sx_segreg, sy_segreg)
    center_offset  = max_scale * np.array([S / 2, S / 2, 0])

    # Apply rotation, translation, and scaling
    transformed_point = crop_tl_ref  + Rz(qz_segreg) @ (point + offset_by_segreg) + center_offset 

    return transformed_point
